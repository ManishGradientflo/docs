---
title: "How It Works"
description: "From PR to mastery in 10 minutes"
---


**Connect GitHub (30 seconds)**\
You connect using a simple OAuth link. No SDK is required.\
Gradientflo only needs read-only access to PR diffs, CI/CD results, and code quality metrics.

**Work Normally**\
You continue your usual workflow: code → commit → push → open a pull request.\
Nothing changes on your side. Gradientflo activates automatically when the PR is opened.

**We Detect Gaps (30 seconds)**\
Gradientflo runs real-time analysis on your PR to detect issues such as:

- Drops in test coverage
- Security vulnerabilities
- Missing error handling
- High code complexity

Example: If test coverage drops by 15%, a Unit Testing ByteCourse is recommended.

**ByteCourse Appears (5 seconds)**\
A GitHub comment is posted automatically with a personalized course recommendation based on the gap detected.\
For example:\
A missing error-handling pattern triggers a short 8-minute “Error Handling in Next.js” ByteCourse.

**Learn in 10 Minutes**\
You click the link and complete an interactive 10-minute lesson that includes:

- Voice narration
- Examples using your actual code
- Supporting artifacts such as slides, mini apps, or diagrams
- A short 3-question quiz

This format yields around 90% knowledge retention (compared to 20% from traditional video tutorials).

**Apply & Verify**\
You push new commits. Gradientflo re-analyzes the PR automatically.\
If the gap is resolved, Gradientflo posts a success comment and updates your Skill Graph with evidence from the PR (e.g., PR-456).

---

## **Real Example**

Sarah had a Redis caching pull request.\
She previously spent 2 hours searching Google for “Redis caching best practices.”\
With Gradientflo, she received a 10-minute personalized ByteCourse generated directly from her own code.

**The result:**

- 110 minutes saved
- 90% retention
- Zero Redis errors in her next pull request

---

## **Call to Action**

You can connect GitHub and start learning directly from your pull requests in minutes.