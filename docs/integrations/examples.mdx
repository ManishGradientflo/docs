---
title: "Examples"
description: "Real PRs. Real courses. Real impact."
---

See Gradientflo in action with real developer workflows.

## Example 1: Missing Error Handling

**PR Context:** Next.js API route with no try/catch

<CodeGroup>

```typescript Before
export async function POST(req: Request) {
  const body = await req.json();
  const user = await db.user.create({ data: body });
  return NextResponse.json(user);
}
```


```typescript After (10-min course)
export async function POST(req: Request) {
  try {
    const body = await req.json();
    const validated = userSchema.parse(body);
    const user = await db.user.create({ data: validated });
    return NextResponse.json(user);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid input', details: error.issues },
        { status: 400 }
      );
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

</CodeGroup>

**ByteCourse:** Error Handling in Next.js (8 mins)\
**Artifacts:** Slides, error handling flowchart, mini app playground\
**Outcome:** Learned Zod validation + typed error handling

---

## Example 2: Redis Caching

**Sarah's PR:** Basic Redis implementation, no TTL, missing error handling

**Old way:** 2 hours Googling "Redis best practices"\
**New way:** 10-minute ByteCourse generated from her code

**ByteCourse covered:**

- Cache invalidation strategies
- TTL configuration
- Connection pooling
- Error handling for cache misses

**Artifacts:**

- Architecture diagram (app â†’ Redis â†’ DB)
- Mini app (live Redis commands)
- Flowchart (cache decision tree)

**Result:** 110 min saved, 90% retention, zero Redis errors next PR

---

## Example 3: Test Coverage Drop

**PR Comment:**

```markdown
ðŸŽ“ Gap Detected: Coverage dropped 15% on UserService.ts
ðŸ“š Course: Unit Testing Best Practices (7 mins)
Evidence: Missing edge case tests for null inputs
```

**After course:** Developer added 8 test cases, coverage back to 85%

---

## Example 4: Security Vulnerability

**PR Context:** SQL injection risk detected by SonarCloud

**Gap Detected:** Raw SQL query with unsanitized user input

<CodeGroup>

```typescript Before
const userId = req.query.id;
const user = await db.raw(`SELECT * FROM users WHERE id = ${userId}`);
```


```typescript After (9-min course)
const userId = req.query.id;
const user = await db.user.findUnique({ 
  where: { id: parseInt(userId) } 
});
```

</CodeGroup>

**ByteCourse:** Secure Coding Fundamentals (9 mins)\
**Artifacts:** Security vulnerability mindmap, attack vector diagram, code playground\
**Evidence:** SonarCloud scan + CodeAnt report\
**Outcome:** Learned parameterized queries, input validation, ORM best practices

---

## Example 5: Code Complexity

**PR Comment:**

```markdown
ðŸŽ“ Gap Detected: Function complexity >15 (cyclomatic)
ðŸ“š Course: Refactoring Complex Functions (10 mins)
Evidence: `processOrder()` has 8 nested conditions
```

**Before:** 120-line function with nested if/else\
**After course:** Refactored into 5 single-responsibility functions

**Artifacts:**

- Before/after architecture diagram
- Complexity heatmap (visual)
- Mini app showing refactoring patterns

**Result:** Code review time reduced from 45 min to 12 min

---

## Example 6: React Server Components

**David's PR:** Mixing client and server components incorrectly

**Gap Detected:**

- Using `useState` in server component
- Fetching data on client instead of server
- Missing `'use client'` directive

**ByteCourse:** Understanding Next.js Server Components (8 mins)

**What he learned:**

- Server vs Client component boundaries
- When to use each pattern
- Data fetching strategies
- Hydration optimization

**Artifacts:**

- Component tree diagram
- Data flow visualization
- Interactive playground (toggle server/client)

**Result:** App load time improved 40%, proper SSR implementation

---

<Card title="Try It Yourself" icon="rocket" href="/quickstart">
  Connect GitHub and learn from your next PR â†’
</Card>